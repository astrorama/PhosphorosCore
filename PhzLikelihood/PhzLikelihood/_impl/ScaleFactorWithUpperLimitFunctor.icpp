/**
 * @file ScaleFactorFunctor.icpp
 * @date December 2, 2014
 * @author Nikolaos Apostolakos
 */

#ifndef SCALEFACTORWITHUPPERLIMITFUNCTOR_ICPP
#define	SCALEFACTORWITHUPPERLIMITFUNCTOR_ICPP

#include <cmath>
#include "PhzLikelihood/ChiSquareWithUpperLimitFunctor.h"
#include "ElementsKernel/Real.h"
#include "ElementsKernel/Logging.h"

namespace Euclid {
namespace PhzLikelihood {

static Elements::Logging scale_factor_logger = Elements::Logging::getLogger("ScaleFactorWithUpperLimitFunctor");

/**
  * @brief Function Call Operator
  * @details
  * Compute the Scale Factor of the source with respect to the model.
  *
  * @param source_begin
  * An iterator over the Filters of the source exposing an object having "flux" and "error" fields.

  * @param source_end
  * End iterator for the Filters of the source.
  *
  * @param model_begin
  * An iterator over the Filters of the model exposing an object containing the model "flux".
  *
  * @return
  * The computed Scale Factor as a double.
  */
template<typename SourceIter, typename ModelIter>
double ScaleFactorWithUpperLimitFunctor::operator ()(SourceIter source, SourceIter source_end,
                                       ModelIter model) const {

    ChiSquareWithUpperLimitFunctor chiSquareFunctor;
    ScaleFactorFunctor scaleForDetectedPhotometry;

    auto s_med = scaleForDetectedPhotometry(source, source_end, model);
    auto s_min = 0.8*s_med;
    auto s_max = 1.1*s_med;
    auto val_min = chiSquareFunctor(source, source_end, model, s_min);
    auto val_med = chiSquareFunctor(source, source_end, model, s_med);
    auto val_max = chiSquareFunctor(source, source_end, model, s_max);

    auto denom = (s_med - s_min)*(val_med-val_max)-(s_med - s_max)*(val_med-val_min);

    auto dist = s_max - s_min;
    int loop=0;
    do {
      loop++;
      auto new_s_med = s_med - 0.5*((s_med-s_min)*(s_med-s_min)*(val_med-val_max)
           -(s_med - s_max)*(s_med - s_max)*(val_med-val_min))/denom;
      if (new_s_med < s_med) {
        s_max = s_med;
        val_max = val_med;
        dist = s_med - new_s_med;
      } else {
        s_min = s_med;
        val_min = val_med;
        dist = new_s_med - s_med;
      }

      s_med = new_s_med;
      val_med= chiSquareFunctor(source, source_end, model, s_med);
      denom = (s_med - s_min)*(val_med-val_max)-(s_med - s_max)*(val_med-val_min);
    } while (!Elements::isEqual(0.,denom) &&  dist>m_accuracy && loop < m_loop_max);

    if (loop == m_loop_max){
      scale_factor_logger.warn()<<"The Scale Factor computation for source with non detection reached the maximum allowed iterations before the expected accuracy.";
    }

    return s_med;
}

} // end of namespace PhzLikelihood
} // end of namespace Euclid

#endif	/* SCALEFACTORWITHUPPERLIMITFUNCTOR_ICPP */

