/** 
 * @file LikelihoodHandler.cpp
 * @date March 13, 2015
 * @author Nikolaos Apostolakos
 */

#include <vector>
#include <CCfits/CCfits>
#include "ElementsKernel/Exception.h"
#include "ElementsKernel/Logging.h"
#include "GridContainer/serialize.h"
#include "PhzUtils/FileUtils.h"

namespace fs = boost::filesystem;

namespace Euclid {
namespace PhzOutput {

template <PhzDataModel::RegionResultType GridType>
struct FullGridOutputTraits;

template <>
struct FullGridOutputTraits<PhzDataModel::RegionResultType::LIKELIHOOD_LOG_GRID> {
  static std::string filename() {return "likelihood";}
};

template <>
struct FullGridOutputTraits<PhzDataModel::RegionResultType::POSTERIOR_LOG_GRID> {
  static std::string filename() {return "posterior";}
};


static Elements::Logging logger = Elements::Logging::getLogger("PhzOutput");

struct HduIdVisitor: public boost::static_visitor<void> {
private:
  CCfits::HDU& m_hdu;

public:
  HduIdVisitor(CCfits::HDU& hdu): m_hdu(hdu) {}

  template <typename T>
  void operator()(const T& id) const {
    m_hdu.addKey("ID", id, "");
  }
};

template<PhzDataModel::RegionResultType GridType>
LikelihoodHandler<GridType>::LikelihoodHandler(boost::filesystem::path out_dir, bool do_sample, size_t sample_number, size_t chunk_size)
          : m_out_dir{std::move(out_dir)}, m_do_sample{do_sample}, m_sample_number{sample_number}, m_chunk_size{chunk_size},m_counter (0) {

      Euclid::PhzUtils::checkCreateDirectoryOnly(m_out_dir.string());

      if (m_do_sample) {
        m_index_file = m_out_dir / "Index_File_"(FullGridOutputTraits<GridType>::filename()+".fits");
        m_index_fits_file = std::make_shared<CCfits::FITS>("!"+m_index_file.string(), CCfits::RWmode::Write);
        // Create the columnInfo object
        m_index_column_info  = std::shared_ptr<Euclid::Table::ColumnInfo>{new Euclid::Table::ColumnInfo {{
          Euclid::Table::ColumnInfo::info_type("OBJECT_ID", typeid(std::string)),
          Euclid::Table::ColumnInfo::info_type("FILE_NAME", typeid(std::string))
        }}};

        m_current_out_file = m_out_dir / "Sample_File_"(FullGridOutputTraits<GridType>::filename()+"_"+std::to_string(m_current_file_id)+".fits");
        m_current_fits_file = std::make_shared<CCfits::FITS>("!"+m_current_out_file.string(), CCfits::RWmode::Write);
        m_ampling_column_info  = std::shared_ptr<Euclid::Table::ColumnInfo>{new Euclid::Table::ColumnInfo {{
                Euclid::Table::ColumnInfo::info_type("OBJECT_ID", typeid(std::string)),
                Euclid::Table::ColumnInfo::info_type("GRID_REGION_INDEX", typeid(std::vector<int>)),
                Euclid::Table::ColumnInfo::info_type("SED_INDEX", typeid(std::vector<int>)),
                Euclid::Table::ColumnInfo::info_type("REDSHIFT_INDEX", typeid(std::vector<int>)),
                Euclid::Table::ColumnInfo::info_type("RED_CURVE_INDEX", typeid(std::vector<int>)),
                Euclid::Table::ColumnInfo::info_type("EB_V_INDEX", typeid(std::vector<int>))
           }}};
      }

}

template <PhzDataModel::RegionResultType GridType>
LikelihoodHandler<GridType>::~LikelihoodHandler() {
  if (m_do_sample) {
    auto logger = Elements::Logging::getLogger("LikelihoodHandler");
    logger.info() << "Created " << FullGridOutputTraits<GridType>::filename() << " index file " << m_index_file.string();
  }
}

template<PhzDataModel::RegionResultType GridType>
void LikelihoodHandler<GridType>::handleSourceOutput(
                                          const SourceCatalog::Source& source,
                                          const PhzDataModel::SourceResults& results) {
  std::string id = boost::lexical_cast<std::string>(source.getId());
  



  if (m_do_sample) {
     std::vector<Table::Row> samples_row_list {};

    // Count the number of sources saved when
     ++m_counter;

     if (m_counter >= m_chunk_size) {
       // change file
       m_counter = 0;
       ++m_current_file_id;
       m_current_fits_file->destroy();
       m_current_out_file = m_out_dir / "Sample_File_"(FullGridOutputTraits<GridType>::filename()+"_"+std::to_string(m_current_file_id)+".fits");
       m_current_fits_file = std::make_shared<CCfits::FITS>("!"+m_current_out_file.string(), CCfits::RWmode::Write);
     }

     std::vector<Table::Row> index_row_list {};
     index_row_list.push_back(Table::Row{{id, m_current_file_id}, m_index_column_info});
     Table::FitsWriter index_fits_writer {m_index_fits_file};
     index_fits_writer.addData(Table::Table{index_row_list});

     if (m_counter == 0) {
       // TODO insert index structure as comment
     }

     // TODO draw sample
     std::vector<int> grid_region_index{};
     std::vector<int> sed_index{};
     std::vector<int> z_index{};
     std::vector<int> red_index{};
     std::vector<int> ebv_index{};

     std::vector<Table::Row> sampling_row_list {};
     index_row_list.push_back(Table::Row{{id, grid_region_index, sed_index, z_index, red_index, ebv_index}, m_ampling_column_info});
     Table::FitsWriter sample_fits_writer {m_current_fits_file};
     sample_fits_writer.addData(Table::Table{sampling_row_list});

  } else {
    // Output full grid in a separate file
    std::string filename = (m_out_dir/(id+".fits")).string();
    fs::remove(filename);

    for (auto& pair : results.get<PhzDataModel::SourceResultType::REGION_RESULTS_MAP>()) {
      auto& grid = pair.second.get<GridType>();
      GridContainer::gridFitsExport(filename, pair.first, grid);
      CCfits::FITS fits (filename, CCfits::Write);
      auto& array_hdu = fits.extension(fits.extension().size() - grid.axisNumber());

      HduIdVisitor visitor{array_hdu};
      auto source_id = source.getId();
      boost::apply_visitor(visitor, source_id);
    }

    logger.debug() << "Created file " << filename << " for source " << id;
  }
}

} // end of namespace PhzOutput
} // end of namespace Euclid
