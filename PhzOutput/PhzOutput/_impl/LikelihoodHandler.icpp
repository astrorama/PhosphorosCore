/** 
 * @file LikelihoodHandler.cpp
 * @date March 13, 2015
 * @author Nikolaos Apostolakos
 */

#include <vector>
#include <random>
#include <CCfits/CCfits>
#include "ElementsKernel/Exception.h"
#include "ElementsKernel/Logging.h"
#include "GridContainer/serialize.h"
#include "PhzUtils/FileUtils.h"
#include "PhzDataModel/PhzModel.h"

namespace fs = boost::filesystem;

namespace Euclid {
namespace PhzOutput {

template <PhzDataModel::RegionResultType GridType>
struct FullGridOutputTraits;

template <>
struct FullGridOutputTraits<PhzDataModel::RegionResultType::LIKELIHOOD_LOG_GRID> {
  static std::string filename() {return "likelihood";}
  static constexpr auto bestModelIterator = PhzDataModel::RegionResultType::BEST_LIKELIHOOD_MODEL_ITERATOR;
};

template <>
struct FullGridOutputTraits<PhzDataModel::RegionResultType::POSTERIOR_LOG_GRID> {
  static std::string filename() {return "posterior";}
  static constexpr auto bestModelIterator = PhzDataModel::RegionResultType::BEST_MODEL_ITERATOR;
};


static Elements::Logging loggerPhz = Elements::Logging::getLogger("PhzOutput");

struct HduIdVisitor: public boost::static_visitor<void> {
private:
  CCfits::HDU& m_hdu;

public:
  HduIdVisitor(CCfits::HDU& hdu): m_hdu(hdu) {}

  template <typename T>
  void operator()(const T& id) const {
    m_hdu.addKey("ID", id, "");
  }
};

template<PhzDataModel::RegionResultType GridType>
LikelihoodHandler<GridType>::LikelihoodHandler(boost::filesystem::path out_dir, bool do_sample, size_t sample_number, size_t chunk_size)
          : m_out_dir{std::move(out_dir)}, m_do_sample{do_sample}, m_sample_number{sample_number}, m_chunk_size{chunk_size},m_counter (0) {

      Euclid::PhzUtils::checkCreateDirectoryOnly(m_out_dir.string());

      if (m_do_sample) {
        std::string file_name = "Index_File_" + FullGridOutputTraits<GridType>::filename() + ".fits";
        m_index_file = m_out_dir / file_name;
        m_index_fits_file = std::make_shared<CCfits::FITS>("!"+m_index_file.string(), CCfits::RWmode::Write);
        // Create the columnInfo object
        m_index_column_info  = std::shared_ptr<Euclid::Table::ColumnInfo>{new Euclid::Table::ColumnInfo {{
          Euclid::Table::ColumnInfo::info_type("OBJECT_ID", typeid(std::string)),
          Euclid::Table::ColumnInfo::info_type("FILE_NAME", typeid(std::string))
        }}};
        std::string samp_file_name = "Sample_File_" + FullGridOutputTraits<GridType>::filename()+"_"+std::to_string(m_current_file_id)+".fits";
        m_current_out_file = m_out_dir / samp_file_name;
        m_current_fits_file = std::make_shared<CCfits::FITS>("!"+m_current_out_file.string(), CCfits::RWmode::Write);
        m_ampling_column_info  = std::shared_ptr<Euclid::Table::ColumnInfo>{new Euclid::Table::ColumnInfo {{
                Euclid::Table::ColumnInfo::info_type("OBJECT_ID", typeid(std::string)),
                Euclid::Table::ColumnInfo::info_type("GRID_REGION_INDEX", typeid(std::vector<int>)),
                Euclid::Table::ColumnInfo::info_type("SED_INDEX", typeid(std::vector<int>)),
                Euclid::Table::ColumnInfo::info_type("REDSHIFT_INDEX", typeid(std::vector<int>)),
                Euclid::Table::ColumnInfo::info_type("RED_CURVE_INDEX", typeid(std::vector<int>)),
                Euclid::Table::ColumnInfo::info_type("EB_V_INDEX", typeid(std::vector<int>))
           }}};
      }

}

template <PhzDataModel::RegionResultType GridType>
LikelihoodHandler<GridType>::~LikelihoodHandler() {
  if (m_do_sample) {
    auto loggerEnd = Elements::Logging::getLogger("LikelihoodHandler");
    loggerEnd.info() << "Created " << FullGridOutputTraits<GridType>::filename() << " index file " << m_index_file.string();
  }
}

template<PhzDataModel::RegionResultType GridType>
void LikelihoodHandler<GridType>::handleSourceOutput(
                                          const SourceCatalog::Source& source,
                                          const PhzDataModel::SourceResults& results) {
  std::string id = boost::lexical_cast<std::string>(source.getId());
  if (m_do_sample) {
    std::vector<Table::Row> samples_row_list {};

    // Count the number of sources saved when
     ++m_counter;

     if (m_counter >= m_chunk_size) {
       // change file
       m_counter = 0;
       ++m_current_file_id;
       m_current_fits_file->destroy();
       std::string file_name = "Sample_File_" + FullGridOutputTraits<GridType>::filename() + "_" + std::to_string(m_current_file_id) + ".fits";
       m_current_out_file = m_out_dir / file_name;
       m_current_fits_file = std::make_shared<CCfits::FITS>("!"+m_current_out_file.string(), CCfits::RWmode::Write);
     }

     std::vector<Table::Row> index_row_list {};
     std::string samp_file_name = "Sample_File_" + FullGridOutputTraits<GridType>::filename()+"_"+std::to_string(m_current_file_id)+".fits";
     index_row_list.push_back({{id, samp_file_name }, m_index_column_info});
     Table::FitsWriter index_fits_writer {m_index_fits_file};
     index_fits_writer.addData(Table::Table{index_row_list});


     Table::FitsWriter sample_fits_writer {m_current_fits_file};
     if (m_counter == 0) {
       std::stringstream comment {};
       comment << "MODEL-GRID : {";
       size_t region_index = 0;
       for (auto& pair : results.get<PhzDataModel::SourceResultType::REGION_RESULTS_MAP>()) {
          comment << "\"" << pair.first << "\": {\"REGION_INDEX\":" << region_index <<",";
          auto& grid = pair.second.get<GridType>();
          auto& axis = grid.getAxesTuple();
          auto& z_axis = std::get<0>(axis);
          comment << "\"Z\":{";
          size_t index=0;
          for ( auto& knot_value : z_axis) {
            comment << "\""<< index <<"\":\""<< knot_value << "\",";
          }
          comment.seekp(-1, comment.cur);
          comment << "}";

          auto& ebv_axis = std::get<1>(axis);
          comment << "\"EBV\":{";
          index=0;
          for ( auto& knot_value : ebv_axis) {
            comment << "\""<< index <<"\":\""<< knot_value << "\",";
          }
          comment.seekp(-1, comment.cur);
          comment << "}";

          auto& red_axis = std::get<2>(axis);
          comment << "\"REDDENING_CURVE\":{";
          index=0;
          for ( auto& knot_value : red_axis) {
            comment << "\""<< index <<"\":\""<< knot_value << "\",";
          }
          comment.seekp(-1, comment.cur);
          comment << "}";

          auto& sed_axis =  std::get<3>(axis);
          comment << "\"SED\":{";
          index=0;
          for ( auto& knot_value : sed_axis) {
            comment << "\""<< index <<"\":\""<< knot_value << "\",";
          }
          comment.seekp(-1, comment.cur);
          comment << "}";
          comment << "}";
          ++region_index;
       }
       comment << "}";
      sample_fits_writer.addComment(comment.str());
    }



     // 1) "Volume" of the different regions
     std::map<size_t,int64_t> region_volume{};
     size_t total_volume = 0;
     size_t region_index = 0;
     std::map<size_t, std::string> region_index_map {};
     double max_value = 0;
     for (auto& pair : results.get<PhzDataModel::SourceResultType::REGION_RESULTS_MAP>()) {
        auto& grid = pair.second.get<GridType>();
        auto& axis = grid.getAxesTuple();
        double  region_max_value = *(pair.second.get<FullGridOutputTraits<GridType>::bestModelIterator>());
        if (max_value < region_max_value) {
          max_value = region_max_value;
        }
        int64_t vol = std::get<0>(axis).size()*std::get<1>(axis).size()*std::get<2>(axis).size()*std::get<3>(axis).size();
        region_volume[region_index] = vol;
        total_volume += vol;
        region_index_map[region_index]=pair.first;
        ++region_index;
     }

     std::vector<int> grid_region_index{};
     std::vector<int> sed_index{};
     std::vector<int> z_index{};
     std::vector<int> red_index{};
     std::vector<int> ebv_index{};

     std::random_device rd;  //Will be used to obtain a seed for the random number engine
     std::mt19937 gen(rd()); //Standard mersenne_twister_engine seeded with rd()
     std::uniform_real_distribution<> distrib_region(0, 1.0);
     std::uniform_real_distribution<> distrib_prob(0, max_value);

     auto& region_map = results.get<PhzDataModel::SourceResultType::REGION_RESULTS_MAP>();

     while (grid_region_index.size() < m_sample_number) {
       double region_draw =  distrib_region(gen);
       int region_idx = 0;
       double already_counted = 0.0;
       while (already_counted + region_volume[region_index] < region_draw) {
         ++region_idx;
         already_counted += region_volume[region_index];
       }

       auto& result_map = results.get<PhzDataModel::SourceResultType::REGION_RESULTS_MAP>();
       auto& grid = result_map.at(region_index_map.at(region_idx)).get<GridType>();
       auto& axis = grid.getAxesTuple();

       std::uniform_int_distribution<> distrib_z(0, std::get<0>(axis).size()-1);
       std::uniform_int_distribution<> distrib_ebv(0, std::get<1>(axis).size()-1);
       std::uniform_int_distribution<> distrib_red(0, std::get<2>(axis).size()-1);
       std::uniform_int_distribution<> distrib_sed(0, std::get<3>(axis).size()-1);

       int z_idx = distrib_z(gen);
       int ebv_idx = distrib_ebv(gen);
       int red_idx = distrib_red(gen);
       int sed_idx = distrib_sed(gen);

       double prob = grid.at(z_idx, ebv_idx, red_idx, sed_idx);
       double draw = distrib_prob(gen);
       if (draw<=prob) {
         grid_region_index.push_back(region_idx);
         sed_index.push_back(sed_idx);
         z_index.push_back(z_idx);
         red_index.push_back(red_idx);
         ebv_index.push_back(ebv_idx);
       }
     }

     std::vector<Table::Row> sampling_row_list {};
     index_row_list.push_back(Table::Row{{id, grid_region_index, sed_index, z_index, red_index, ebv_index}, m_ampling_column_info});

     sample_fits_writer.addData(Table::Table{sampling_row_list});

  } else {
    // Output full grid in a separate file
    std::string filename = (m_out_dir/(id+".fits")).string();
    fs::remove(filename);

    for (auto& pair : results.get<PhzDataModel::SourceResultType::REGION_RESULTS_MAP>()) {
      auto& grid = pair.second.get<GridType>();
      GridContainer::gridFitsExport(filename, pair.first, grid);
      CCfits::FITS fits (filename, CCfits::Write);
      auto& array_hdu = fits.extension(fits.extension().size() - grid.axisNumber());

      HduIdVisitor visitor{array_hdu};
      auto source_id = source.getId();
      boost::apply_visitor(visitor, source_id);
    }

    loggerPhz.debug() << "Created file " << filename << " for source " << id;
  }
}

} // end of namespace PhzOutput
} // end of namespace Euclid
