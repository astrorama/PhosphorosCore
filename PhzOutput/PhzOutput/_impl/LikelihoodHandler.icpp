/** 
 * @file LikelihoodHandler.cpp
 * @date March 13, 2015
 * @author Nikolaos Apostolakos
 */

#include <vector>
#include <random>
#include <CCfits/CCfits>
#include "ElementsKernel/Exception.h"
#include "ElementsKernel/Logging.h"
#include "GridContainer/serialize.h"
#include "PhzUtils/FileUtils.h"
#include "PhzDataModel/PhzModel.h"

namespace fs = boost::filesystem;

namespace Euclid {
namespace PhzOutput {

template <PhzDataModel::RegionResultType GridType>
struct FullGridOutputTraits;

template <>
struct FullGridOutputTraits<PhzDataModel::RegionResultType::LIKELIHOOD_LOG_GRID> {
  static std::string filename() {return "likelihood";}
  static constexpr auto bestModelIterator = PhzDataModel::RegionResultType::BEST_LIKELIHOOD_MODEL_ITERATOR;
};

template <>
struct FullGridOutputTraits<PhzDataModel::RegionResultType::POSTERIOR_LOG_GRID> {
  static std::string filename() {return "posterior";}
  static constexpr auto bestModelIterator = PhzDataModel::RegionResultType::BEST_MODEL_ITERATOR;
};


static Elements::Logging loggerPhz = Elements::Logging::getLogger("PhzOutput");

struct HduIdVisitor: public boost::static_visitor<void> {
private:
  CCfits::HDU& m_hdu;

public:
  HduIdVisitor(CCfits::HDU& hdu): m_hdu(hdu) {}

  template <typename T>
  void operator()(const T& id) const {
    m_hdu.addKey("ID", id, "");
  }
};

template<PhzDataModel::RegionResultType GridType>
LikelihoodHandler<GridType>::LikelihoodHandler(boost::filesystem::path out_dir, bool do_sample, size_t sample_number, size_t chunk_size)
          : m_out_dir{std::move(out_dir)}, m_do_sample{do_sample}, m_sample_number{sample_number}, m_chunk_size{chunk_size},m_counter (0) {

      Euclid::PhzUtils::checkCreateDirectoryOnly(m_out_dir.string());

      if (m_do_sample) {
        std::string file_name = "Index_File_" + FullGridOutputTraits<GridType>::filename() + ".fits";
        m_index_file = m_out_dir / file_name;
        m_index_fits_file = std::make_shared<CCfits::FITS>("!"+m_index_file.string(), CCfits::RWmode::Write);
        // Create the columnInfo object
        m_index_column_info  = std::shared_ptr<Euclid::Table::ColumnInfo>{new Euclid::Table::ColumnInfo {{
          Euclid::Table::ColumnInfo::info_type("OBJECT_ID", typeid(std::string)),
          Euclid::Table::ColumnInfo::info_type("FILE_NAME", typeid(std::string))
        }}};
        std::string samp_file_name = "Sample_File_" + FullGridOutputTraits<GridType>::filename()+"_"+std::to_string(m_current_file_id)+".fits";
        m_current_out_file = m_out_dir / samp_file_name;
        m_current_fits_file = std::make_shared<CCfits::FITS>("!"+m_current_out_file.string(), CCfits::RWmode::Write);
        m_ampling_column_info  = std::shared_ptr<Euclid::Table::ColumnInfo>{new Euclid::Table::ColumnInfo {{
                Euclid::Table::ColumnInfo::info_type("OBJECT_ID", typeid(std::string)),
                Euclid::Table::ColumnInfo::info_type("GRID_REGION_INDEX", typeid(std::vector<int>)),
                Euclid::Table::ColumnInfo::info_type("SED_INDEX", typeid(std::vector<int>)),
                Euclid::Table::ColumnInfo::info_type("REDSHIFT", typeid(std::vector<float>)),
                Euclid::Table::ColumnInfo::info_type("RED_CURVE_INDEX", typeid(std::vector<int>)),
                Euclid::Table::ColumnInfo::info_type("EB_V", typeid(std::vector<float>))
           }}};
      }

}

template <PhzDataModel::RegionResultType GridType>
LikelihoodHandler<GridType>::~LikelihoodHandler() {
  if (m_do_sample) {
    Table::FitsWriter index_fits_writer {m_index_fits_file};
    index_fits_writer.addData(Table::Table{m_index_row_list});
    m_index_fits_file->destroy();
    m_current_fits_file->destroy();
    auto loggerEnd = Elements::Logging::getLogger("LikelihoodHandler");
    loggerEnd.info() << "Created " << FullGridOutputTraits<GridType>::filename() << " index file " << m_index_file.string();
  }
}

template<PhzDataModel::RegionResultType GridType>
void LikelihoodHandler<GridType>::handleSourceOutput(
                                          const SourceCatalog::Source& source,
                                          const PhzDataModel::SourceResults& results) {
  std::string id = boost::lexical_cast<std::string>(source.getId());
  loggerPhz.info() << "Outputing the "<< FullGridOutputTraits<GridType>::filename() << " for souce with id "<< id;
  if (m_do_sample) {
    std::vector<Table::Row> samples_row_list {};
    std::string samp_file_name = "Sample_File_" + FullGridOutputTraits<GridType>::filename()+"_"+std::to_string(m_current_file_id)+".fits";

     if (m_counter >= m_chunk_size) {
       // change file
       m_counter = 0;
       ++m_current_file_id;
       m_current_fits_file->destroy();
       samp_file_name = "Sample_File_" + FullGridOutputTraits<GridType>::filename() + "_" + std::to_string(m_current_file_id) + ".fits";
       m_current_out_file = m_out_dir / samp_file_name;
       m_current_fits_file = std::make_shared<CCfits::FITS>("!"+m_current_out_file.string(), CCfits::RWmode::Write);
       loggerPhz.info() << "Creating new sample files ";
     }

     Table::FitsWriter sample_fits_writer {m_current_fits_file};

     if (m_counter == 0) {
       std::stringstream comment {};
       comment << "MODEL-GRID : {";
       size_t region_index = 0;
       for (auto& pair : results.get<PhzDataModel::SourceResultType::REGION_RESULTS_MAP>()) {

          //loggerPhz.info() << "Build comment for region  "<<pair.first;

          comment << "\"" << pair.first << "\": {\"REGION_INDEX\":" << region_index <<",";
          auto& grid = pair.second.get<GridType>();
          auto& axis = grid.getAxesTuple();
          size_t index=0;

    /*    auto& z_axis = std::get<0>(axis);
          comment << "\"Z\":{";
          for ( auto& knot_value : z_axis) {
            comment << "\""<< index <<"\":\""<< knot_value << "\",";
            ++index;
          }
          comment.seekp(-1, comment.cur);
          comment << "}";

          auto& ebv_axis = std::get<1>(axis);
          comment << "\"EBV\":{";
          index=0;
          for ( auto& knot_value : ebv_axis) {
            comment << "\""<< index <<"\":\""<< knot_value << "\",";
            ++index;
          }
          comment.seekp(-1, comment.cur);
          comment << "}";*/

          auto& red_axis = std::get<2>(axis);
          comment << "\"REDDENING_CURVE\":{";
          index=0;
          for ( auto& knot_value : red_axis) {
            comment << "\""<< index <<"\":\""<< knot_value << "\",";
            ++index;
          }
          comment.seekp(-1, comment.cur);
          comment << "}";

          auto& sed_axis =  std::get<3>(axis);
          comment << "\"SED\":{";
          index=0;
          for ( auto& knot_value : sed_axis) {
            comment << "\""<< index <<"\":\""<< knot_value << "\",";
            ++index;
          }
          comment.seekp(-1, comment.cur);
          comment << "}";
          comment << "}";
          ++region_index;
       }
       comment << "}";
      sample_fits_writer.addComment(comment.str());

      loggerPhz.info() << "Add comment to the sample file ";
    }


     // 1) "Volume" of the different regions
     std::map<size_t,int64_t> region_volume{};
     size_t total_volume = 0;
     size_t region_index = 0;
     std::map<size_t, std::string> region_index_map {};
     double max_value = 0;

     for (auto& pair : results.get<PhzDataModel::SourceResultType::REGION_RESULTS_MAP>()) {
        auto& grid = pair.second.get<GridType>();
        auto& axis = grid.getAxesTuple();
        double  region_max_value = exp(*(pair.second.get<FullGridOutputTraits<GridType>::bestModelIterator>()));

        if (max_value < region_max_value) {
          max_value = region_max_value;
        }
        int64_t vol = std::get<0>(axis).size()*std::get<1>(axis).size()*std::get<2>(axis).size()*std::get<3>(axis).size();
        region_volume[region_index] = vol;
        total_volume += vol;
        region_index_map[region_index]=pair.first;
        //loggerPhz.info() << "Region " << pair.first << " Max prob= " << region_max_value << " volume="<< vol;
        ++region_index;
        //loggerPhz.info() << "volume of the Region " << pair.first << " :"<<vol;
     }
     //loggerPhz.info() << "Total volume = " << total_volume << " Max prob value = " << max_value;

     std::vector<int> grid_region_index{};
     std::vector<int> sed_index{};
     std::vector<int> red_index{};
     std::vector<float> z_value{};
     std::vector<float> ebv_value{};

     std::random_device rd;  //Will be used to obtain a seed for the random number engine
     std::mt19937 gen(rd()); //Standard mersenne_twister_engine seeded with rd()
     std::uniform_real_distribution<> distrib_region(0, 1.0);
     std::uniform_real_distribution<> distrib_prob(0, max_value);

     auto& region_map = results.get<PhzDataModel::SourceResultType::REGION_RESULTS_MAP>();

     while (grid_region_index.size() < m_sample_number) {
       // loggerPhz.info() << "Sampling  " << grid_region_index.size();
       double region_draw =  distrib_region(gen);

       //loggerPhz.info() << "Region draw  " << region_draw;
       int region_idx = 0;
       double already_counted = region_volume.at(region_idx)/(1.0*total_volume);
       while (already_counted < region_draw) {
         //loggerPhz.info() << "already_counted " << already_counted <<" "<<region_volume.at(region_idx);
         ++region_idx;

         if(region_idx>=region_volume.size()) {
           region_idx = region_volume.size() -1;
           break;
         } else {
           already_counted += region_volume.at(region_idx)/(1.0*total_volume);
         }
       }

       auto& result_map = results.get<PhzDataModel::SourceResultType::REGION_RESULTS_MAP>();
       auto& grid = result_map.at(region_index_map.at(region_idx)).get<GridType>();
       auto& axis = grid.getAxesTuple();

       std::uniform_int_distribution<> distrib_red(0, std::get<2>(axis).size()-1);
       std::uniform_int_distribution<> distrib_sed(0, std::get<3>(axis).size()-1);
       auto& z_axis = std::get<0>(axis);
       auto& ebv_axis = std::get<1>(axis);
       std::uniform_real_distribution<> distrib_z(z_axis[0], z_axis[z_axis.size()-1]);
       std::uniform_real_distribution<> distrib_ebv(ebv_axis[0], ebv_axis[ebv_axis.size()-1]);

       float z_val = distrib_z(gen);
       float ebv_val = distrib_ebv(gen);
       int red_idx = distrib_red(gen);
       int sed_idx = distrib_sed(gen);

       // get the indexes for the bilinear interpolation: those are the indexes of the knot after the value
       size_t z_index_up = 0;
       while (z_axis[z_index_up] < z_val) {
         ++z_index_up;
       }

       size_t ebv_index_up = 0;
       while (ebv_axis[ebv_index_up] < ebv_val) {
        ++ebv_index_up;
       }

       size_t z_index_down = z_index_up!=0 ? z_index_up -1 : 0;
       size_t ebv_index_down = ebv_index_up!=0?ebv_index_up -1 : 0;

       //get the for points
       float z_1 = z_axis[z_index_down];
       float z_2 = z_axis[z_index_up];
       float ebv_1 = ebv_axis[ebv_index_down];
       float ebv_2 = ebv_axis[ebv_index_up];

       double prob11 = exp(grid.at(z_index_down, ebv_index_down, red_idx, sed_idx));
       double prob12 = exp(grid.at(z_index_down, ebv_index_up, red_idx, sed_idx));
       double prob21 = exp(grid.at(z_index_up, ebv_index_down, red_idx, sed_idx));
       double prob22 = exp(grid.at(z_index_up, ebv_index_up, red_idx, sed_idx));

       // interpolation in z (if needed)
       double prob_ebv1 = z_index_up!=z_index_down ? prob11 + (z_val - z_1)*(prob21 - prob11)/(z_2 - z_1) : prob11;
       double prob_ebv2 = z_index_up!=z_index_down ? prob12 + (z_val - z_1)*(prob22 - prob12)/(z_2 - z_1) : prob12;
       // interpolation in ebv (if needed)
       double prob = ebv_index_up!=ebv_index_down ? prob_ebv1 + (ebv_val - ebv_1)*(prob_ebv2 - prob_ebv1)/(ebv_2 - ebv_1) : prob_ebv1;

       double draw = distrib_prob(gen);
       if (draw<=prob) {
         //loggerPhz.info() << "Sampling  in region:" << region_idx << " z " << z_val<< " ebv " << ebv_val<< " red " << red_idx<< " sed " << sed_idx << " Sampling prob:" << prob << " draw " << draw << " current_accepted_number " << grid_region_index.size();

         grid_region_index.push_back(region_idx);
         sed_index.push_back(sed_idx);
         z_value.push_back(z_val);
         red_index.push_back(red_idx);
         ebv_value.push_back(ebv_val);
       }
     }
     //loggerPhz.info() << "Add data to the sampling file ";
     std::vector<Table::Row> sampling_row_list {};
     sampling_row_list.push_back(Table::Row{{id, grid_region_index, sed_index, z_value, red_index, ebv_value}, m_ampling_column_info});
     sample_fits_writer.addData(Table::Table{sampling_row_list});
     //loggerPhz.info() << "Add info to index file ";
     m_index_row_list.push_back({{id, samp_file_name }, m_index_column_info});

     ++m_counter;

  } else {
    // Output full grid in a separate file
    std::string filename = (m_out_dir/(id+".fits")).string();
    fs::remove(filename);

    for (auto& pair : results.get<PhzDataModel::SourceResultType::REGION_RESULTS_MAP>()) {
      auto& grid = pair.second.get<GridType>();
      GridContainer::gridFitsExport(filename, pair.first, grid);
      CCfits::FITS fits (filename, CCfits::Write);
      auto& array_hdu = fits.extension(fits.extension().size() - grid.axisNumber());

      HduIdVisitor visitor{array_hdu};
      auto source_id = source.getId();
      boost::apply_visitor(visitor, source_id);
    }

    loggerPhz.debug() << "Created file " << filename << " for source " << id;
  }
}

} // end of namespace PhzOutput
} // end of namespace Euclid
