/**
 * @file LikelihoodHandler.cpp
 * @date March 13, 2015
 * @author Nikolaos Apostolakos
 */

#include "ElementsKernel/Exception.h"
#include "ElementsKernel/Logging.h"
#include "GridContainer/serialize.h"
#include "PhzDataModel/PhzModel.h"
#include "PhzUtils/FileUtils.h"
#include "XYDataset/QualifiedName.h"
#include "boost/lexical_cast.hpp"
#include <CCfits/CCfits>
#include <random>
#include <vector>

namespace fs = boost::filesystem;

namespace Euclid {
namespace PhzOutput {

template <PhzDataModel::RegionResultType GridType>
struct FullGridOutputTraits;

template <>
struct FullGridOutputTraits<PhzDataModel::RegionResultType::LIKELIHOOD_LOG_GRID> {
  static std::string filename() {
    return "likelihood";
  }
};

template <>
struct FullGridOutputTraits<PhzDataModel::RegionResultType::POSTERIOR_LOG_GRID> {
  static std::string filename() {
    return "posterior";
  }
};

template <>
struct FullGridOutputTraits<PhzDataModel::RegionResultType::LIKELIHOOD_SCALING_LOG_GRID> {
  static std::string filename() {
    return "likelihood";
  }
};

template <>
struct FullGridOutputTraits<PhzDataModel::RegionResultType::POSTERIOR_SCALING_LOG_GRID> {
  static std::string filename() {
    return "posterior";
  }
};

static Elements::Logging loggerPhz = Elements::Logging::getLogger("PhzOutput");

struct HduIdVisitor : public boost::static_visitor<void> {
private:
  CCfits::HDU& m_hdu;

public:
  HduIdVisitor(CCfits::HDU& hdu) : m_hdu(hdu) {}

  template <typename T>
  void operator()(const T& id) const {
    m_hdu.addKey("ID", id, "");
  }
};

template <PhzDataModel::RegionResultType GridType, typename Sampler>
LikelihoodHandler<GridType, Sampler>::LikelihoodHandler(
    boost::filesystem::path out_dir, const std::map<std::string, std::map<std::string, std::pair<double, double>>>& param_config,
    bool do_sample, size_t sample_number, size_t chunk_size)
    : m_out_dir{std::move(out_dir)}
    , m_param_config{param_config}
    , m_do_sample{do_sample}
    , m_sample_number{sample_number}
    , m_chunk_size{chunk_size}
    , m_counter(0)
    , m_grid_sampler{} {

  // loggerPhz.info()<<"Consctuctor call";
  Euclid::PhzUtils::checkCreateDirectoryOnly(m_out_dir.string());

  if (m_do_sample) {
    std::string file_name = "Index_File_" + FullGridOutputTraits<GridType>::filename() + ".fits";
    m_index_file          = m_out_dir / file_name;
    m_index_fits_file     = std::make_shared<CCfits::FITS>("!" + m_index_file.string(), CCfits::RWmode::Write);
    // Create the columnInfo object
    m_index_column_info = std::shared_ptr<Table::ColumnInfo>{
        new Euclid::Table::ColumnInfo{{Euclid::Table::ColumnInfo::info_type("OBJECT_ID", typeid(std::string)),
                                       Euclid::Table::ColumnInfo::info_type("FILE_NAME", typeid(std::string))}}};

    createAndOpenSampleFile();

    std::vector<Euclid::Table::ColumnInfo::info_type> info_list{
        Euclid::Table::ColumnInfo::info_type("OBJECT_ID", typeid(std::string)),
        Euclid::Table::ColumnInfo::info_type("GRID_REGION_INDEX", typeid(int)),
        Euclid::Table::ColumnInfo::info_type("SED_NAME", typeid(std::string)),
        Euclid::Table::ColumnInfo::info_type("REDSHIFT", typeid(float)),
        Euclid::Table::ColumnInfo::info_type("RED_CURVE", typeid(std::string)),
        Euclid::Table::ColumnInfo::info_type("EB_V", typeid(float)),
        Euclid::Table::ColumnInfo::info_type("LUMINOSITY", typeid(float))};

    for (auto iter = m_param_config.begin(); iter != m_param_config.end(); ++iter) {
      loggerPhz.info() << "Creating sampler columns adding " << iter->first;
      info_list.push_back(Table::ColumnInfo::info_type(iter->first, typeid(float)));
    }

    m_sampling_column_info = std::shared_ptr<Euclid::Table::ColumnInfo>{new Euclid::Table::ColumnInfo{info_list}};
  }
}

template <PhzDataModel::RegionResultType GridType, typename Sampler>
LikelihoodHandler<GridType, Sampler>::~LikelihoodHandler() {
  if (m_do_sample) {
    Table::FitsWriter index_fits_writer{m_index_fits_file};
    index_fits_writer.addData(Table::Table{m_index_row_list});
    m_index_fits_file->destroy();
    closeSampleFile();
    auto loggerEnd = Elements::Logging::getLogger("LikelihoodHandler");
    loggerEnd.info() << "Created " << FullGridOutputTraits<GridType>::filename() << " index file " << m_index_file.string();
  }
}

template <PhzDataModel::RegionResultType GridType, typename Sampler>
std::string LikelihoodHandler<GridType, Sampler>::getFileName(int file_id) {
  return "Sample_File_" + FullGridOutputTraits<GridType>::filename() + "_" + std::to_string(file_id) + ".fits";
}

template <PhzDataModel::RegionResultType GridType, typename Sampler>
void LikelihoodHandler<GridType, Sampler>::createAndOpenSampleFile() {
  m_counter                  = 0;
  m_current_file_has_comment = false;
  ++m_current_file_id;
  std::string samp_file_name = getFileName(m_current_file_id);
  m_current_out_file         = m_out_dir / samp_file_name;
  m_current_fits_file        = std::make_shared<CCfits::FITS>("!" + m_current_out_file.string(), CCfits::RWmode::Write);
  m_sample_fits_writer       = std::make_shared<Table::FitsWriter>(m_current_fits_file);
  loggerPhz.info() << "Creating new sample files " << samp_file_name;
}

template <PhzDataModel::RegionResultType GridType, typename Sampler>
void LikelihoodHandler<GridType, Sampler>::closeSampleFile() {
  m_current_fits_file->destroy();
}

template <PhzDataModel::RegionResultType GridType, typename Sampler>
void LikelihoodHandler<GridType, Sampler>::exportFullGrid(const SourceCatalog::Source&       source,
                                                          const PhzDataModel::SourceResults& results) {
  // Output full grid in a separate file
  std::string id       = boost::lexical_cast<std::string>(source.getId());
  std::string filename = (m_out_dir / (id + ".fits")).string();
  fs::remove(filename);

  // Grid container cannot export grid of vector + we should store alpha and sigma grid along to be able to recompute the scaling
  // axis... so exporting the non-sampled grid...
  for (auto& pair : results.get<PhzDataModel::SourceResultType::REGION_RESULTS_MAP>()) {
    if (GridType == PhzDataModel::RegionResultType::LIKELIHOOD_LOG_GRID ||
        GridType == PhzDataModel::RegionResultType::LIKELIHOOD_SCALING_LOG_GRID) {
      auto& grid = pair.second.get<PhzDataModel::RegionResultType::LIKELIHOOD_LOG_GRID>();
      GridContainer::gridFitsExport(filename, pair.first, grid);
      CCfits::FITS fits(filename, CCfits::Write);
      auto&        array_hdu = fits.extension(fits.extension().size() - grid.axisNumber());

      HduIdVisitor visitor{array_hdu};
      auto         source_id = source.getId();
      boost::apply_visitor(visitor, source_id);
    } else {
      auto& grid = pair.second.get<PhzDataModel::RegionResultType::POSTERIOR_LOG_GRID>();
      GridContainer::gridFitsExport(filename, pair.first, grid);
      CCfits::FITS fits(filename, CCfits::Write);
      auto&        array_hdu = fits.extension(fits.extension().size() - grid.axisNumber());

      HduIdVisitor visitor{array_hdu};
      auto         source_id = source.getId();
      boost::apply_visitor(visitor, source_id);
    }
  }

  loggerPhz.debug() << "Created file " << filename << " for source " << id;
}

template <PhzDataModel::RegionResultType GridType, typename Sampler>
std::vector<Table::Row>
LikelihoodHandler<GridType, Sampler>::drawSample(std::string source_id, const std::map<std::string, double>& region_volume,
                                                 const std::map<std::string, PhzDataModel::RegionResults>& result_map) {
  std::random_device rd;         // Will be used to obtain a seed for the random number engine
  std::mt19937       gen(rd());  // Standard mersenne_twister_engine seeded with rd()
  auto               sample = m_grid_sampler.drawSample(m_sample_number, region_volume, result_map, gen);

  loggerPhz.debug() << "Add data to the sampling file ";
  std::vector<Table::Row> sampling_row_list{};
  for (auto& s : sample) {
    auto                               sed_qualified = s.sed.qualifiedName();
    std::vector<Table::Row::cell_type> values{source_id, s.region_index, sed_qualified, s.z, s.red_curve.qualifiedName(),
                                              s.ebv,     s.alpha};
    for (auto& param : m_param_config) {
      float param_value = float(param.second.at(sed_qualified).first * s.alpha + param.second.at(sed_qualified).second);
      values.push_back(param_value);
    }

    sampling_row_list.push_back(Table::Row{values, m_sampling_column_info});
  }
  return sampling_row_list;
}

template <PhzDataModel::RegionResultType GridType, typename Sampler>
void LikelihoodHandler<GridType, Sampler>::handleSourceOutput(const SourceCatalog::Source&       source,
                                                              const PhzDataModel::SourceResults& results) {
  std::string id = boost::lexical_cast<std::string>(source.getId());
  loggerPhz.debug() << "Outputting the " << FullGridOutputTraits<GridType>::filename() << " for source with id " << id;

  if (m_do_sample) {
    // 1) "Volume" of the different regions
    std::map<std::string, double> region_volume{};

    for (auto& pair : results.get<PhzDataModel::SourceResultType::REGION_RESULTS_MAP>()) {
      region_volume[pair.first] = m_grid_sampler.computeEnclosingVolumeOfCells(pair.second);
    }

    // Draw the samples
    auto sampling_row_list = drawSample(id, region_volume, results.get<PhzDataModel::SourceResultType::REGION_RESULTS_MAP>());

    // Flush output file
    if (m_counter >= m_chunk_size) {
      closeSampleFile();
      createAndOpenSampleFile();
    }

    // Add comment if the current output file does not have it
    if (!m_current_file_has_comment) {
      m_current_file_has_comment = true;
      auto comment               = Sampler::createComment(results);
      m_sample_fits_writer->addComment(comment.str());
      loggerPhz.info() << "Add comment to the sample file ";
    }
    m_sample_fits_writer->addData(Table::Table{sampling_row_list});

    // loggerPhz.info() << "Add info to index file ";
    std::string samp_file_name = getFileName(m_current_file_id);
    m_index_row_list.push_back({{id, samp_file_name}, m_index_column_info});

    ++m_counter;

  } else {
    exportFullGrid(source, results);
  }
}

}  // end of namespace PhzOutput
}  // end of namespace Euclid
