/**
 * @file GridSampler.icpp
 * @date 18/08/2020
 * @author DubathF
 **/

#include "ElementsKernel/Exception.h"
#include "ElementsKernel/Logging.h"
#include "GridContainer/serialize.h"
#include "MathUtils/PDF/NdSampler.h"
#include "MathUtils/PDF/NdSamplerFromGrid.h"
#include "NdArray/NdArray.h"
#include "PhzDataModel/DoubleGrid.h"
#include "PhzDataModel/PhzModel.h"
#include "PhzOutput/GridSampler.h"
#include "PhzUtils/FileUtils.h"
#include "boost/lexical_cast.hpp"
#include <CCfits/CCfits>
#include <algorithm>  // std::max
#include <random>
#include <vector>

namespace Euclid {
namespace PhzOutput {

static Elements::Logging loggerPhzGridSampler = Elements::Logging::getLogger("GridSampler");

template <PhzDataModel::RegionResultType GridType>
GridSampler<GridType>::GridSampler() {}

template <PhzDataModel::RegionResultType GridType>
std::stringstream GridSampler<GridType>::createComment(const PhzDataModel::SourceResults& results) {
  std::stringstream comment{};
  comment << "MODEL-GRID : {";
  size_t region_index = 0;
  for (auto& pair : results.get<PhzDataModel::SourceResultType::REGION_RESULTS_MAP>()) {

    // loggerPhzGridSampler.info() << "Build comment for region  "<<pair.first;

    comment << "\"" << pair.first << "\": {\"REGION_INDEX\":" << region_index << ",";
    auto&  grid  = pair.second.get<GridType>();
    auto&  axis  = grid.getAxesTuple();
    size_t index = 0;

    auto& red_axis = std::get<2>(axis);
    comment << "\"REDDENING_CURVE\":{";
    index = 0;
    for (auto& knot_value : red_axis) {
      comment << "\"" << index << "\":\"" << knot_value << "\",";
      ++index;
    }
    comment.seekp(-1, comment.cur);
    comment << "},";

    auto& sed_axis = std::get<3>(axis);
    comment << "\"SED\":{";
    index = 0;
    for (auto& knot_value : sed_axis) {
      comment << "\"" << index << "\":\"" << knot_value << "\",";
      ++index;
    }
    comment.seekp(-1, comment.cur);
    comment << "}";
    comment << "}";
    ++region_index;
  }
  comment << "}";

  return comment;
}

template <PhzDataModel::RegionResultType GridType>
double GridSampler<GridType>::interpolateProbability(double z_0, double z_1, double ebv_0, double ebv_1, double p_00, double p_01,
                                                     double p_10, double p_11, double z_p, double ebv_p) const {
  // interpolation in z (if needed)
  double prob_ebv1 = z_0 != z_1 ? p_00 + (z_p - z_0) * (p_10 - p_00) / (z_1 - z_0) : p_00;
  double prob_ebv2 = z_0 != z_1 ? p_01 + (z_p - z_0) * (p_11 - p_01) / (z_1 - z_0) : p_01;

  // interpolation in ebv (if needed)
  double prob = ebv_0 != ebv_1 ? prob_ebv1 + (ebv_p - ebv_0) * (prob_ebv2 - prob_ebv1) / (ebv_1 - ebv_0) : prob_ebv1;
  return prob;
}

template <PhzDataModel::RegionResultType GridType>
std::pair<double, std::vector<posterior_cell>>
GridSampler<GridType>::computeEnclosingVolumeOfCells(const PhzDataModel::RegionResults& results) const {
  auto&                       grid = results.get<GridType>();
  auto&                       axis = grid.getAxesTuple();
  std::vector<posterior_cell> cells_list{};
  double                      total_cell_vol = 0.;
  size_t                      index_1        = 1;
  for (size_t sed_index = 0; sed_index < std::get<3>(axis).size(); ++sed_index) {
    for (size_t red_index = 0; red_index < std::get<2>(axis).size(); ++red_index) {
      for (size_t ebv_index = 0; ebv_index < std::max(index_1, std::get<1>(axis).size() - 1); ++ebv_index) {
        for (size_t z_index = 0; z_index < std::max(index_1, std::get<0>(axis).size() - 1); ++z_index) {
          double delta_z = 1.0;
          double delta_e = 1.0;
          double v_00    = exp(grid.at(z_index, ebv_index, red_index, sed_index));
          double v_10    = v_00;
          double v_01    = v_00;
          double v_11    = v_00;
          if (std::get<0>(axis).size() > 1) {
            v_10    = exp(grid.at(z_index + 1, ebv_index, red_index, sed_index));
            v_11    = v_10;
            delta_z = std::get<0>(axis)[z_index + 1] - std::get<0>(axis)[z_index];
          }

          if (std::get<1>(axis).size() > 1) {
            v_01    = exp(grid.at(z_index, ebv_index + 1, red_index, sed_index));
            v_11    = v_01;
            delta_e = std::get<1>(axis)[ebv_index + 1] - std::get<1>(axis)[ebv_index];
          }

          if (std::get<0>(axis).size() > 1 && std::get<1>(axis).size() > 1) {
            v_11 = exp(grid.at(z_index + 1, ebv_index + 1, red_index, sed_index));
          }

          double v_max = std::max(std::max(v_00, v_10), std::max(v_01, v_11));
          double value = 0.25 * (v_00 + v_10 + v_01 + v_11) * delta_z * delta_e;

          auto cell = posterior_cell{sed_index, red_index, ebv_index, z_index, 0, v_max, value};
          total_cell_vol += value;
          cells_list.push_back(cell);
        }
      }
    }
  }

  return std::make_pair(total_cell_vol, cells_list);
}

template <typename... Axes>
static std::unique_ptr<MathUtils::InterpN<Axes...>>
createInterpolatorFromGrid(const GridContainer::GridContainer<std::vector<double>, Axes...>& grid) {
  auto knots        = MathUtils::ExtractKnots<Euclid::_make_index_sequence<sizeof...(Axes)>>::extract(grid.getAxesTuple());
  auto values_shape = MathUtils::ExtractKnots<Euclid::_make_index_sequence<sizeof...(Axes)>>::extractShape(grid.getAxesTuple());
  NdArray::NdArray<double> values(values_shape, grid.begin(), grid.end());
  return Euclid::make_unique<MathUtils::InterpN<Axes...>>(std::move(knots), std::move(values), true);
}

template <typename... Axes>
std::unique_ptr<MathUtils::NdSampler<Axes...>>
createSamplerFromGrid(const GridContainer::GridContainer<std::vector<double>, Axes...>& grid) {
  auto knots     = MathUtils::ExtractKnots<Euclid::_make_index_sequence<sizeof...(Axes)>>::extract(grid.getAxesTuple());
  auto pdf_shape = MathUtils::ExtractKnots<Euclid::_make_index_sequence<sizeof...(Axes)>>::extractShape(grid.getAxesTuple());
  NdArray::NdArray<double> pdf(pdf_shape, grid.begin(), grid.end());
  std::transform(pdf.begin(), pdf.end(), pdf.begin(), [](double v) { return std::exp(v); });
  return Euclid::make_unique<MathUtils::NdSampler<Axes...>>(std::move(knots), std::move(pdf));
}

template <PhzDataModel::RegionResultType GridType>
std::vector<GridSample>
GridSampler<GridType>::drawSample(std::size_t sample_number, const std::map<std::string, double>& region_volume_map,
                                  const std::map<std::string, PhzDataModel::RegionResults>& results, std::mt19937& gen) {
  // Prepare a sampler per region
  using SamplerPtrType = std::unique_ptr<MathUtils::NdSampler<double, double, XYDataset::QualifiedName, XYDataset::QualifiedName>>;
  using InterpolationPtrType =
      std::unique_ptr<MathUtils::InterpN<double, double, XYDataset::QualifiedName, XYDataset::QualifiedName>>;

  std::vector<SamplerPtrType>       samplers;
  std::vector<InterpolationPtrType> scaling_grid;
  std::vector<std::string>          region_names;
  std::vector<double>               r_cumulative;
  samplers.reserve(results.size());
  scaling_grid.reserve(results.size());
  region_names.reserve(results.size());
  r_cumulative.reserve(results.size());

  double total_volume = 0.;
  for (auto& pair : results) {
    auto& grid       = pair.second.get<GridType>();
    auto& scale_grid = pair.second.get<PhzDataModel::RegionResultType::SCALE_FACTOR_GRID>();
    samplers.emplace_back(std::move(createSamplerFromGrid(grid)));
    scaling_grid.emplace_back(std::move(createInterpolatorFromGrid(scale_grid)));
    region_names.emplace_back(pair.first);
    total_volume += region_volume_map.at(pair.first);
    r_cumulative.emplace_back(total_volume);
  }
  std::uniform_real_distribution<> distrib_region(0, total_volume);

  // Reserve output
  std::vector<GridSample> sample(sample_number);

  // To make things faster, select regions first, then take all needed samples within region
  std::vector<size_t> draws_per_region(region_names.size());
  for (size_t i = 0; i < sample_number; ++i) {
    double region_draw  = distrib_region(gen);
    int    region_index = std::lower_bound(r_cumulative.begin(), r_cumulative.end(), region_draw) - r_cumulative.begin();
    ++draws_per_region[region_index];
  }

  // Draws samples from regions
  size_t i = 0;
  for (size_t region_index = 0; region_index < draws_per_region.size(); ++region_index) {
    int ndraws = draws_per_region[region_index];
    if (ndraws == 0)
      continue;

    std::vector<std::tuple<double, double, XYDataset::QualifiedName, XYDataset::QualifiedName>> output(
        ndraws, std::make_tuple(0, 0, DefaultQualifiedName, DefaultQualifiedName));

    // Use the sampler for that region for all except alpha
    samplers[region_index]->draw(ndraws, gen, output);

    for (auto& d : output) {
      auto& s        = sample[i++];
      s.region_index = region_index;

      std::tie(s.z, s.ebv, s.red_curve, s.sed) = output[0];

      // Compute alpha from its grid
      s.alpha = (*scaling_grid[s.region_index])(s.z, s.ebv, s.red_curve, s.sed);
    }
  }

  // Done!
  return sample;
}

}  // end of namespace PhzOutput
}  // end of namespace Euclid
