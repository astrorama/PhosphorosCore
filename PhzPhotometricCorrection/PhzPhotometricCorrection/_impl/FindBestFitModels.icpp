/**
 * @file PhzPhotometricCorrection/FindBestFitModels.h
 * @date Jan 16, 2015
 * @author Florian Dubath
 */

#include <map>
#include <algorithm>
#include "SourceCatalog/Catalog.h"
#include "PhzLikelihood/SourcePhzFunctor.h"
#include "ElementsKernel/Exception.h"
#include "ElementsKernel/Logging.h"

#include "PhzLikelihood/LikelihoodGridFunctor.h"
#include "PhzLikelihood/LikelihoodLogarithmAlgorithm.h"
#include "PhzLikelihood/ScaleFactorFunctor.h"
#include "PhzLikelihood/ChiSquareLikelihoodLogarithm.h"

namespace Euclid {
namespace PhzPhotometricCorrection {

/**
 * @brief The const UNSETZ is used as an initialization vwhen looking for the redshift
 */
static constexpr double UNSETZ =-1.;

/**
 * @brief The const MAXIMALZ is used as the initialization value for the
 * redshift difference when looking for minimal difference value.
 */
static constexpr double MAXIMALZ=1100.;

template<typename SourceCalculatorFunctor>
std::map<int64_t, PhzDataModel::PhotometryGrid::const_iterator> FindBestFitModels<SourceCalculatorFunctor>::operator()(
    const SourceCatalog::Catalog& calibration_catalog,
    const std::map<std::string, PhzDataModel::PhotometryGrid>& model_grid_map,
    const PhzDataModel::PhotometricCorrectionMap& photometric_correction) {

  using namespace std;

  using mp = PhzDataModel::ModelParameter;

  auto best_fit_map = map<int64_t, PhzDataModel::PhotometryGrid::const_iterator>();

  for (auto& source : calibration_catalog) {

    int64_t source_id = source.getId();

    shared_ptr < SourceCatalog::SpectroscopicRedshift > redshift_ptr =
        source.getAttribute<SourceCatalog::SpectroscopicRedshift>();

    if (redshift_ptr==nullptr){
          throw Elements::Exception()<<"Source with Id "<< source_id
             << " has no spectroscopic redshift attribute";
    }

    double expected_redshift = redshift_ptr->getValue();

    shared_ptr < SourceCatalog::Photometry > photometry_ptr =
        source.getAttribute<SourceCatalog::Photometry>();
    if (photometry_ptr==nullptr){
          throw Elements::Exception()<<"Source with Id "<< source_id
              << " has no photometry attribute";
    }
    
    std::map<std::string, PhzDataModel::PhotometryGrid> sliced_grid_map {};
    for (auto& pair : model_grid_map) {
      // If this region does not contain the redshift in its range we ignore it
      auto& z_axis = pair.second.getAxis<mp::Z>();
      if (expected_redshift < z_axis[0] || expected_redshift > z_axis[z_axis.size()-1]) {
        continue;
      }
      // Find the closest Z value for the region
      double closest_z = UNSETZ;
      double zs_diff = MAXIMALZ;
      for (auto& z_value : z_axis) {
        double curr_diff = std::abs(z_value - expected_redshift);
        if (curr_diff < zs_diff) {
          closest_z = z_value;
          zs_diff = curr_diff;
        }
      }
      // Add the slice in the map. We need to do a little trick to manage to
      // move the result of the fixAxisByValue, to remove its constness
      const PhzDataModel::PhotometryGrid& const_slice =
                  pair.second.fixAxisByValue<mp::Z>(closest_z);
      PhzDataModel::PhotometryGrid& slice = const_cast<PhzDataModel::PhotometryGrid&>(const_slice);
      sliced_grid_map.emplace(std::make_pair(pair.first, std::move(slice)));
    }
    // If we have no grids in the sliced_grid_map means that we have no region
    // that contains the source redshift. For this reason we ignore it, as it
    // is outside the regions we have models for
    if (sliced_grid_map.empty()) {
      continue;
    }

    SourceCalculatorFunctor source_phz_calculator (
        photometric_correction, sliced_grid_map,
        PhzLikelihood::LikelihoodGridFunctor {
          PhzLikelihood::LikelihoodLogarithmAlgorithm {
            PhzLikelihood::ScaleFactorFunctorUpperLimitMissingData {},
            PhzLikelihood::ChiSquareLikelihoodLogarithmUpperLimitMissingData {}
          }
        }
    );

    // We must return an iterator to the correct input grid, not to the slice, so we
    // create a new iterator and we fix its axes
    const PhzDataModel::SourceResults& slice_res = source_phz_calculator(*photometry_ptr);
    auto slice_iter = slice_res.get<PhzDataModel::SourceResultType::BEST_MODEL_ITERATOR>();
    for (auto& pair : model_grid_map) {
      auto grid_iter = pair.second.begin();
      try {
        grid_iter.fixAxisByValue<mp::SED>(slice_iter.template axisValue<mp::SED>());
        grid_iter.fixAxisByValue<mp::REDDENING_CURVE>(slice_iter.template axisValue<mp::REDDENING_CURVE>());
        grid_iter.fixAxisByValue<mp::EBV>(slice_iter.template axisValue<mp::EBV>());
        grid_iter.fixAxisByValue<mp::Z>(slice_iter.template axisValue<mp::Z>());
        best_fit_map.emplace(source_id, grid_iter);
        break;
      } catch (const Elements::Exception&) {
        // If we got an exception means that the result is in a different region
      }
    }
  }

  return best_fit_map;
}

} // end of namespace PhzPhotometricCorrection
} // end of namespace Euclid

