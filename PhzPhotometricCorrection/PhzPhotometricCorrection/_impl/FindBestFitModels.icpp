/**
 * @file PhzPhotometricCorrection/FindBestFitModels.h
 * @date Jan 16, 2015
 * @author Florian Dubath
 */

#include <map>
#include <algorithm>
#include "SourceCatalog/Catalog.h"
#include "PhzLikelihood/SourcePhzFunctor.h"
#include "ElementsKernel/Exception.h"
#include "ElementsKernel/Logging.h"

#include "PhzLikelihood/LikelihoodGridFunctor.h"
#include "PhzLikelihood/LikelihoodLogarithmAlgorithm.h"
#include "PhzLikelihood/ScaleFactorFunctor.h"
#include "PhzLikelihood/ChiSquareLikelihoodLogarithm.h"

namespace Euclid {
namespace PhzPhotometricCorrection {

/**
 * @brief The const UNSETZ is used as an initialization vwhen looking for the redshift
 */
static constexpr double UNSETZ =-1.;

/**
 * @brief The const MAXIMALZ is used as the initialization value for the
 * redshift difference when looking for minimal difference value.
 */
static constexpr double MAXIMALZ=1100.;

template<typename SourceCalculatorFunctor>
FindBestFitModels<SourceCalculatorFunctor>::FindBestFitModels(
                                        LikelihoodGridFunction likelihood_func,
                                        std::vector<PriorFunction> priors)
        : m_likelihood_func(likelihood_func), m_priors(priors) {
}

template<typename SourceCalculatorFunctor>
std::map<int64_t, PhzDataModel::PhotometryGrid::const_iterator> FindBestFitModels<SourceCalculatorFunctor>::operator()(
    const SourceCatalog::Catalog& calibration_catalog,
    const std::map<std::string, PhzDataModel::PhotometryGrid>& model_grid_map,
    const PhzDataModel::PhotometricCorrectionMap& photometric_correction) {

  using namespace std;
  auto logger = Elements::Logging::getLogger("FindBestFitModels");

  auto best_fit_map = map<int64_t, PhzDataModel::PhotometryGrid::const_iterator>();
  
  // We are going to ignore any source that its redshift is outside of all model
  // grid ranges, as it cannot give us any useful information. For this reason
  // we compute the ranges of the model grids here to not repeat it for every
  // source and we create a lambda function to do the check.
  std::vector<std::pair<double, double>> grid_z_range_list {};
  for (auto& pair : model_grid_map) {
    auto& z_axis = pair.second.getAxis<PhzDataModel::ModelParameter::Z>();
    grid_z_range_list.emplace_back(z_axis[0], z_axis[z_axis.size()-1]);
  }
  auto zInRange = [grid_z_range_list](double z) {
    for (auto& range : grid_z_range_list) {
      if (z >= range.first && z <= range.second) {
        return true;
      }
    }
    return false;
  };

  for (auto& source : calibration_catalog) {

    int64_t source_id = source.getId();

    shared_ptr < SourceCatalog::SpectroscopicRedshift > redshift_ptr =
        source.getAttribute<SourceCatalog::SpectroscopicRedshift>();

    if (redshift_ptr==nullptr){
          throw Elements::Exception()<<"Source with Id "<< source_id
             << " has no spectroscopic redshift attribute";
    }

    double expected_redshift = redshift_ptr->getValue();
    
    // If the redshift of the source is not in the model grid range we ignore it
    if (!zInRange(expected_redshift)) {
      logger.info() << "Ignoring source with ID " << source_id << " because its "
              << "spectroscopic redshift (" << expected_redshift << ") is outside "
              << "the model grid range";
      continue;
    }

    shared_ptr < SourceCatalog::Photometry > photometry_ptr =
        source.getAttribute<SourceCatalog::Photometry>();
    if (photometry_ptr==nullptr){
          throw Elements::Exception()<<"Source with Id "<< source_id
              << " has no photometry attribute";
    }

    SourceCalculatorFunctor source_phz_calculator (
        photometric_correction, model_grid_map, m_likelihood_func, m_priors
    );

    const PhzDataModel::SourceResults& res = source_phz_calculator(*photometry_ptr, expected_redshift);
    best_fit_map.emplace(source_id, res.get<PhzDataModel::SourceResultType::BEST_MODEL_ITERATOR>());
  }

  return best_fit_map;
}

} // end of namespace PhzPhotometricCorrection
} // end of namespace Euclid

